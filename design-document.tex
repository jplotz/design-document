\documentclass[12pt]{article}

\usepackage{minted}

\usepackage{float}
\usepackage{graphicx}
\graphicspath{{graphics/}}

\usepackage[margin=1in]{geometry}
\usepackage{setspace}
\onehalfspacing

% Include a list of logos of some of the project's tech stack,
% all on one line. Each logo is limited to a maximum size of 1"x1"
% per the assignment instructions. It isn't mentioned explicitly
% but I would assume numbered captions are not required for simple logos.
\newcommand{\onelinelogos}{
\begin{figure}[H]
	\centering
	$\vcenter{\hbox{\includegraphics[keepaspectratio,width=1in,height=1in]{django-logo-negative}}}$
	\hspace{0.1in}
	$\vcenter{\hbox{\includegraphics[keepaspectratio,width=1in,height=1in]{python-logo}}}$
	\hspace{0.1in}
	$\vcenter{\hbox{\includegraphics[keepaspectratio,width=1in,height=1in]{javascript-logo}}}$
	\hspace{0.1in}
	$\vcenter{\hbox{\includegraphics[keepaspectratio,width=1in,height=1in]{docker-logo-blue}}}$
	\hspace{0.1in}
	$\vcenter{\hbox{\includegraphics[keepaspectratio,width=1in,height=1in]{aws-logo}}}$
\end{figure}
}

% For simple quarter-page graphics.
% Parameters: filename, caption, label
\newcommand{\simplegraphic}[3] {
\begin{figure}[H]
	\centering
	\includegraphics[keepaspectratio,height=0.25\textheight,width=\textwidth]{#1}
	\caption{#2}
	\label{#3}
\end{figure}
}

% Half-page graphic ("very complex figures or screenshots with a lot of information").
% Parameters: filename, caption, label
\newcommand{\complexgraphic}[3] {
\begin{figure}[H]
	\centering
	\includegraphics[keepaspectratio,height=0.5\textheight,width=\textwidth]{#1}
	\caption{#2}
	\label{#3}
\end{figure}
}

\usepackage{subfiles}


\title{Preliminary Design Document}
\author{
	Dustin Allen
	\and
	Daniel Armas
	\and
	Rithik Dhakshnamoorthy
	\and
	Jacob Plotz
	\and
	Luke Samuel Sandoval
	\and
	Jereme Saunders
}
\date{October 2025}

\begin{document}

\maketitle

% Should not be more than two pages in the final PDF
\tableofcontents

\section{Executive Summary}

\section{Project Description}

\subsection {Overview}
The Web App Deployment Tooling (WADT) project allows students and instructors to browse a catalog of ready-to-deploy vulnerable webapps and manage them through a graphical interface. WADT is the first step in the learning pipeline that ensures students and instructors are on the same page in minimal time. Their efforts can shift to investigating the app itself, while the container-based architecture of WADT ensures they have reproducible sandboxed builds available at the click of a button.

\subsection{The Setup Timesink Problem}
Cybersecurity students want to practice exploiting and patching vulnerable webapps. When they sit down to practice, their time is eaten up by installation and setup before they can start hacking.

Cybersecurity instructors want to provide labs for their students. These labs require research, setup, installation, and testing. The instructor must take the time to guide each student through the same prerequisite steps before the real learning can begin.

Both parties are capable of following a list of instructions to set up a target webapp. These skills are not the desired target of practice. However, requiring setup work on a per-lab basis means wasting learning time.

\subsection{Project Goals and Objectives}
WADT aims to eliminate redundant setup work by providing a standardized environment where vulnerable web apps can be deployed instantly in isolated containers. This ensures reproducibility, simplifies lab setup, and allows both instructors and students to focus on the learning objectives.

\section{Minimum Viable Product}

\subsection{How our MVP Solves the Setup Timesink Problem}
The Web App Deployment Tooling (WADT) project allows students and instructors to browse a catalog of ready-to-deploy vulnerable webapps and manage them through a graphical interface. WADT is the first step in the learning pipeline that ensures students and instructors are on the same page in minimal time. Their efforts can shift to investigating the app itself, while the container-based architecture of WADT ensures they have reproducible sandboxed builds available at the click of a button.

\subsection{Scope and Limitations}
WADT is intended to be used in an instructional setting as part of a lab. While all code developed for the project is free and open-source, the site and the AWS instance it runs on are not accessible to the general public. The team members and sponsor are the only individuals expected to access the site and instance while it is in early development.

Later in development, our users will access both the WADT site and the instance through their instructor similar to how we have accessed these two resources. We expect that users (assisted by instructors) are capable of reproducing our instructions for accessing the instance and authenticating to access the site when we provide these documents.

The current scope of WADT does not provision for multiple concurrent users at a time with containers managed on a per-identity basis. Each container may be associated with one and the same identity, under the assumption that students will actively collaborate and share management of the containers.

\subsection{Hosting and Security Considerations}
Hosting vulnerable applications on a public, internet-facing server is considered a bad practice. Special precautions must be taken to ensure that malicious actors cannot compromise the instance through a vulnerable container, and that the containers themselves are not compromised and used for criminal purposes.

A viable solution may be to avoid hosting the site at all. It is technically possible for the site to be kept local-only and require each student to download and run the project from their own machine. However, this would largely defeat the purpose of the project as it would require its own setup and installation steps.

Another option may be to install and configure the project local-only on the AWS instance but avoid exposing the instance to the public internet. Each student would be required to connect to the instance through a VPN. The preceding two solutions are dead simple to the point of being below the level of sophistication expected of a 9-month project.

A more feasible solution would be to host the site and add an extremely restrictive security configuration. The instance could be configured to only accept incoming traffic from and send outgoing traffic to a small number of IPs or an IP range explicitly listed in a whitelist. This solution is ideal if the machines used in the lab have IP addresses that fall within a specific range or are unlikely to change over a semester-long course. Under this scheme, the target webapp containers would be blocked from making requests to third parties. Discretion would be left up entirely to the students (a rogue student would have the ability to change the whitelist).

\subsection{Vulnerable App Selection and Containerization}
In order to give our users a variety of options to choose from, we want to select a diverse set of vulnerable web applications. There is an existing registry of vulnerable web applications known as the OWASP Vulnerable Web Applications Directory (VWAD). This registry contains a variety of web applications that are intentionally designed to be vulnerable for educational purposes. We will select at least 7 web applications from this registry that cover a range of vulnerabilities and technologies.

The web applications listed in this registry record the technologies used as well as the specific vulnerabilities they contain. This information will help us ensure that we are providing a comprehensive and varied set of applications for our users to work with.

Creating a quality docker image for each web application is a non-trivial task. We will need to ensure that each image is reliable (it always deploys when required) and reproducible (the application source code and initial state are immutable and consistent). This may involve creating custom Dockerfiles, configuring the applications correctly, and testing the images thoroughly.

\subsection{Technical Debt and Maintainability}
While we may assume one identity controls all containers, it may still be smarter in the long run to design for the possibility of multiple concurrent users, even if this isn't made possible by our hosting configuration.

Since "make it support multiple users" is an excellent goal if this project returns to Senior Design, we will design for the possibility of this extension by programmatically tracking container IDs and associating them with the user's identity and actions. This design decision also makes it easier for us to manage state and tell the user "You cannot stop a container you haven't deployed!" even in the single-user version of WADT.

As a stretch goal, future teams that work on this project would be able to extend our API instead of rewriting it.

\subsection{"Do One Thing Well"}
WADT is a stage in a learning pipeline. Pipelines are made possible by small, focused applications that do one thing well and rely on standard interfaces. WADT is an abstraction for managing containers. It is not an abstraction over the process of finding API endpoints, making requests, patching, and testing. Therefore, WADT should use conventional input and output formats and get out of the way of the user's preferred tools.

If all the user needs is a URL, provide the URL in an easy-to-copy format. Nothing else.

\subsection{Definition of Done}
\begin{itemize}
	\item At least 7 target vulnerable webapps are listed on the site with icons, names, and descriptions. An image for each webapp has been created and tested for reliability (always deploys when required) and reproducibility (application source code and initial state are immutable and consistent). Each target app passes automated tests ensuring that the desired vulnerable endpoints are confirmed reachable.
	\item Container limits. Each container is alloted a specific amount of compute resources and network bandwidth. Each container is only kept running for a maximum of 24 hours from the last user interaction, at which point it will be automatically downed.
	\item Status indicator. Each webapp indicates its state. State indication matches actual container behavior (does not indicate stop when container with specified ID is still running, etc.).
	\item Deploy feature. Users can deploy any of the target webapps. Deploy is accompanied by connection information, assisting users in making requests to the vulnerable application.
	\item Stop feature. Users can stop any webapp. Stop only functions for containers which are currently running.
	\item Restart feature. Users can restart each webapp. "Restart" in this context means stop the webapp the student has been working on patching and start it again.
	\item Reset feature. "Reset" means to stop the version of the app the student has been working on, and deploy the original image before any modifications were made.
	\item Instructor controls. Site admins can view logs with the status of each container. Each deploy, stop, and restart action is logged. Admins have the option of deploy, stop, and restart, and their actions override the wishes of users (while preventing race conditions and state inconsistency). Instructors have the option to "disable" a container, meaning that the container leaves control of the students and only the instructors can manage it. When a container is disabled, students are unable to make any state changes to the container.
	\item Student-facing logging. Student-facing logs must provide a window into the container's behavior, without burdening the student with unnecessary Docker-specific details. For students, no single action in the UI should require scrolling the view of the logs (everything resulting from one action should fit on one view). All major interactions through the UI should be logged with timestamps. The logger must preserve history from the moment the container is started to the moment it is manually downed or auto-downed after 24 hours. In the event of an error resulting from a failed attempt to patch a vulnerability, the student must receive the full error message.
	\item Instructor-facing logging. Must show timestamped logs of all actions taken through the UI by students. Must show container status changes. Uptime for each container must be available to instructors.
\end{itemize}

\subsection{Stretch Goals}
\begin{itemize}
	\item Instructor-facing controls to add new containers. The admin interface provides a method to upload a custom Dockerfile and add that image to the catalog. Instructors will be able to add container metadata (name, description, tags, category, etc.). This new container will function identically to the containers built-in to the site.
	\item Automatic patch checking. User communicates which API endpoints they wish to patch, and the site automatically checks periodically if that endpoint is still vulnerable. Status reports are generated showing which of a set of endpoints are still reachable at the time the report is generated.
	\item UI allows editing of network settings per-container. Users can customize port number on a per-container basis through the UI.
	\item System resource usage display. Admin UI displays, in addition to container uptime, CPU, memory, and network usage for each container.
	\item Custom colorschemes.
	      Make site compatible with widely used color scheme file formats (minimum: .Xresources, .itermcolors, Windows settings.json, and .yml used for GNOME terminal and xfce4 terminal). Students will be able to use the same colors for WADT and for their terminal.
	\item Custom interactions window. Users can issue (arbitrary) commands to the container through the site. Users may edit files with a text editor through the site. This stretch goal is extremely ambitious. The security vulnerabilities potentially resulting from exposing a shell to a container are numerous and severe. Additionally, embedding a full terminal emulator inside of a webapp is a difficult task.
\end{itemize}

% Describe technologies used to make MVP possible
\section{Research}

\subsection{Hosting Provider}
\subsubsection{DigitalOcean}
DigitalOcean droplets are small-sized virtual machines that are billed on a monthly basis.
The team has previous experience using DigitalOcean droplets for hosting, making a Basic droplet a potential choice. However, since WADT is a SaaS application, in DigitalOcean's own terms a Basic droplet may not suffice. Additional tiers of compute and memory would impose an unfair cost on the student group.

\subsubsection{BuyVM}
BuyVM virtual machines are cheaper than a DigitalOcean droplet, but lack the support and convenient admin UI of DigitalOcean or AWS. BuyVM would allow maximum control and potentially a relatively unique hosting stack comprised of a hardened *BSD distribution. However, this route was not chosen for the first iteration of WADT due to the high learning curve.

\subsubsection{AWS}
AWS EC2 was recommended by our sponsor and provided and paid for by our sponsor. This made it an attractive option for the team, even if the pricing model creates risks and additional considerations regarding extensive network traffic. AWS benefits from extensive documentation and high configurability. Ultimately, a single instance was chosen to start with the option of scaling to additional instances as usage of the project grows.

\subsection{Host Operating System}
\subsubsection{OpenBSD}
OpenBSD is a security-focused UNIX system. While using a security-focused system for a cybersecurity-focused project is a good idea, the relative scarcity of documentation meant a steep learning curve for the team.

Considering a *BSD distribution was quickly invalidated as the team determined that Docker is a Linux-specific application. Docker relies on Linux kernel namespaces as part of its core design, meaning that to use a *BSD distribution would require dramatic changes in other parts of the project, effectively invalidating WADT's original purpose. A BSD-based project would make use of Jails instead of Docker. Since users expect to manipulate Docker containers with WADT, changing to BSD would require a change in our MVP, making it more than a mere technical decision.

\subsubsection{CentOS}
CentOS is a Linux distribution which is used internally for the labs run by our sponsor. For the purposes of our users, the main functional difference they will experience between CentOS and other choices of distribution is the package manager. Key project pieces (Docker, NGINX, etc.) are available for every Linux distribution the team considered, the only difference between them being familiarity.

It was decided to optimize for our developer team's productivity in the beginning, and since no member had previous experience with CentOS, it was decided to postpone its adoption. WADT can be migrated to CentOS for lab instructors and students once its core features are developed.

\subsubsection{Amazon Linux}
Amazon Linux is a distribution provided by Amazon specifically for EC2 instances. Its primary advantage for the team would be easy integration with IaC tools like Terraform and CloudFormation.

Amazon Linux is not ideal for either developers or users in terms of previous experience and familiarity. It is not used internally within labs and was not used for testing and early development.

\subsubsection{Ubuntu}
Ubuntu was chosen to promote a fast ramp-up and make it easy for every member of the team to contribute. Ubuntu is an ideal choice, since it supports all elements of the project tech stack and is widely-used.

Specifically, Ubuntu by default enforces an externally-managed Python environment which effectively necessitates using virtual environments to manage project dependencies. This ensures no developers have conflicts between project-specific packages and system-wide packages and reduces dependency conflicts.

PostgreSQL is also available in Ubuntu's default repositories, simplifying project setup when compared to CentOS or Amazon Linux.

\subsection{General Security Concerns}
\subsection{2-Factor Authentication}

\subsection{Containerization Tools}
\subsubsection{OCI Compliance}
The Open Container Initiative (OCI) maintains a group of three specifications which containerization tools are expected to follow to be compliant to the same standards as Docker. Since Docker was taken as a baseline technology for the project, only other OCI-compliant containerization tools were considered.

\subsubsection{Podman}
Podman is a drop-in replacement for Docker which is both daemonless and rootless. It differs in its underlying architecture: Podman is pod-based. A pod is an infra container combined with a number of regular containers.

For comparison, plain Docker functions interacts with plain containers, not pods. Docker Compose can be used to run multiple containers together for a project.

\simplegraphic{podman-pod-architecture}{Pod architecture}{fig:podman}
% source: https://developers.redhat.com/blog/2019/01/15/podman-managing-containers-pods#

Podman's daemonless design means that it does not require a running background process (daemon) to function. Instead, Podman relies on systemd. This is in contrast to Docker, which requires a daemon with root privileges.

Podman is also rootless, meaning that system root privileges are not required by any part of Podman to run containers. This feature is the biggest draw of Podman over Docker for a security-focused project. With Podman, WADT would never require root privileges to run containers or be forced to interact with a privileged daemon process.

Although Podman is intended as a drop-in replacement for Docker, there are minor differences which ultimately led to the team's selection of Docker instead. Docker can perform pulls from DockerHub with short image names, while Podman requires additional configuration to do so. So while \texttt{docker pull postgres} will run successfully, \texttt{podman pull postgres} will throw an error.

These small differences are likely to create cognitive friction for users of WADT.


\subsubsection{Docker}
Docker is a widely-used set of container tools. A number of features made Docker the ideal choice for WADT.
\begin{itemize}
	\item Official, extensive SDK with available low-level API access
	\item Images already available for numerous applications. While any OCI-compliant container engine can run these images, in practice they are built and tested for Docker
	\item DockerHub integration
\end{itemize}

\subsection{Programming Language and Web Framework}

\subsubsection{Python and Flask}
Too minimal

\subsubsection{Golang and Gin}
Too minimal. Also golang is a new language for i assume most or all of the team

\subsubsection{Python and Django}
Django is a web framework for Python which was chosen for its sensible architecture and useful features. Django's ORM and admin panel made configuring the database a one-day job, while its migrations feature ensures that any changes are tracked along with the project.

Django's MVC architecture and template system enforces clear separation of concerns and makes prototyping fast and easy. Combined with its powerful ORM, simple views can be implemented in a few lines of code.
\begin{figure}[H]
	\centering
	\begin{minted}{python}
	def index(request):
	    container_catalog = Container.objects.order_by("name")
	    context = {"container_catalog": container_catalog}
	    return render(request, "wadtapp/index.html", context)
	\end{minted}
	\caption{Django queries and template system make simple pages simple to write.}
	\label{fig:indexview}
\end{figure}

\subsection{Docker Integration}

\subsubsection{python-on-whales}
good, but only for Docker Compose

\subsubsection{go-sdk}
not using it because we're not using go

\subsubsection{docker-py}
good

\subsection{Asynchronous Support}

\subsubsection{Celery}
too complex

\subsubsection{Django Channels}
good. prevents the client from repeatedly polling the server

\subsection{Backend Architecture}

\subsubsection{Django MVC}
what's meant here is using django's built in stuff for rendering HTML templates with whatever data you want.

\subsubsection{API-only}
what's meant here is using Django to create an API that just sends and receives JSON and doesn't take responsibility for rendering pages, which is what we're actually doing.


\subsection{API Testing}

\subsubsection{cURL}
yay!

\subsubsection{Postman}
ew

\subsection{API Documentation}

\subsubsection{Hoppscotch}
free and open-source

\subsubsection{SwaggerHub}
I don't like swaggerhub

\subsection{API Performance Testing}

\subsection{Secrets Management}
TruffleHog

\subsection{CI/CD Pipeline}

% Descrbie what technologies we used/considered and why chosen technology was selected
\subsection{Database}

\subsubsection{MySQL}
bruh absolutely not

\subsubsection{MariaDB}
better but still MySQL is kinda clunky

\subsubsection{MongoDB}
requires a third-party backend to be used with Django

\subsubsection{PostgreSQL}
well-supported, easy to install and once you figure out how to set it up, it's not that hard to reproduce those steps.

\subsection{Container Identity Management}
the problem of figuring out which container is which. container name and container id are both guaranteed to be unique by docker, but which one we need to use depends on context.

\subsection{Docker Compose}
docker compose afaik requires a different python library than just
one-container-at-a-time, which means if any webapps we want on WADT
use compose, we need a way to use a different library to control them.

\subsection{Docker Architecture}

% docker team stuff here I suppose


% Again, placeholder title, just for ideas for this section
\subsection{Frontend}


\section{System Architecture}


\section{Timeline and Milestones}

\end{document}
