\documentclass[../design-document.tex]{subfiles}
\begin{document}

\subsection{ProtoWADT v0}
The first prototype was created to explore controlling Docker containers programmatically and gain familiarity with Django. This prototype was timeboxed to a 1-day sprint to prohibit overanalysis and decision paralysis.

The scope was intentionally basic and focused on only programmatically controlling one container, instead of the usual 7-10. It ran local-only,
depended on a specific vulnerable app (DVWA), and was intended to be thrown away.

ProtoWADT v0 was also a vital exploration of some of the invalid assumptions the team had made previously about our tech stack. Different libraries were depended on than originally predicted as a result of this exploration. This prototype also began the thinking which led to further design exploration and investigation of hidden complexity in the next prototype.

The prototype's definition of done required that at least the core states of Docker containers could be manipulated through API endpoints. Start, Restart, Logs, Stop, and Down were initially required.

A crucial oversight of this prototype was the lack of a database, which hid further problems with state and storage that were not discovered until the second prototype. The decision to store important data in memory for a local-only demo sidestepped issues of data corruption, handling asynchronous connections, and scaling that are discussed in more detail in \ref{subsec:api-considerations} and \ref{subsec:container-identity-management}.

\subsubsection{Programmatic Control}
The first goal of v0 was to programmatically control Docker containers with a suitable programming language. For Python, two main libraries exist that fit this purpose: python-on-whales and docker-py. Broadly, docker-py is intended for applications that run as a single container, and python-on-whales is intended for applications that run as a group of containers with Docker Compose as well as single-container applications. Since DVWA specifically uses Docker Compose to run multiple containers, python-on-whales was selected for the prototype.

First, a short demo was created that essentially listed and used the main parts of the python-on-whales API that the project would depend on. python-on-whales has essentially a one-to-one correspondence beteween its API and the Docker CLI command structure, meaning that finding these endpoints was often as easy as typing the command with Python syntax.

\begin{figure}[H]
	\centering
	\begin{minted}{console}
	docker compose up --detach
	\end{minted}
	\caption{\texttt{docker} command syntax}
	\label{fig:docker-compose-up-cli}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{minted}{python}
	docker.compose.up(detach=True)
	\end{minted}
	\caption{python-on-whales API}
	\label{fig:docker-compose-up-python}
\end{figure}

The key failures of this prototype related to the scope. A standard Python program has a synchronous top-down control flow, meaning that a given sequence of method calls to a single DockerClient object in memory will occur as expected. However, a web server aiming to provide the same service cannot use this model of execution.

Instead, the DockerClient object cannot be shared in memory between REST API endpoints without mechanisms for data persistence (serialization and storage in the session, cache, database, etc.) and data integrity (preventing race conditions or invalid states).

At a deeper level, HTTP is a stateless protocol. Specific to the project, shared state between requests needs to be managed by a separate system server-side. Sharing data between views as a global variable, such as providing a global DockerClient for all views to access, is not a sufficient solution due to the potential for data corruption.

A WSGI server typically assigns each request to a worker process or thread, meaning that sharing global variables in memory would break down upon deployment. While python-on-whales guarantees that their DockerClient object does not store any state that will affect program execution, docker-py does not make a similar guarantee. In the end, the potential for the ``share global variables in memory" approach is bad design which may or may not work depending on the Docker library used.

\subsubsection{Django}
The second goal of v0 was to understand how Django is used to build webapps. A basic demo site was created with views to control the DVWA container. The completion criteria involved creating URLs for each Docker action and writing a view to achieve each. Completion was manually tested by monitoring container state with Docker Desktop while using the written views. Start, restart, stop, down, and logs views were required.

Each of these endpoints was simple due to the lack of complexity of the scope of the prototype. More complex requests for continuous information like container CPU usage were not considered. As a result, the prototype v0 didn't reveal much about how to write the views of our project, but did teach the team how to structure a Django project overall.

Gaps in the team's understanding, resulting from an insufficiently detailed prototype, were (partially) corrected by the second which was developed.

\subsection{ProtoWADT v1}
The next prototype iteration explored the use of Django REST Framework (DRF) to develop a REST API. Alternative models were experimented with (figure \ref{fig:alt-model}).
The new, simplified model relies on an external Docker registry to pull images.

The simplified model incorporates insights gained from the first prototype and a better understanding of the divide in the project between persistent and temporary information.

\subsubsection{Persistent Data}
\begin{itemize}
	\item A container's metadata (display name and description) are not likely to change for the duration of its existence on the WADT site.
	\item A container's registry URL is fixed for the duration of its lifespan. Changing the registry URL changes the container. Crucially, incorporating
	      knowledge of an external registry into the database makes it easier for the Docker team to manage and debug images. Docker team need only concern
	      themselves with modifying an image and updating it on an external registry, rather than pushing changes through idiosyncratic, project-specific means.
\end{itemize}

\subsubsection{Temporary Data}
\begin{itemize}
	\item Docker container ID and Docker-provided name. These are auto-generated by the Docker Engine.
	\item State information. The containers must display status indications such as running or stopped. Since
	      these values are relatively ephemeral, it doesn't make sense to store them in a database.
	\item Uptime. Container uptime is a continuously-changing value, and hence it doesn't make sense to store
	      it in a database for the same reasons as state information.
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{minted}{python}
# Jimmy's Container
display_name = models.CharField(max_length=32)
# He wrote this in one day. #PHP #MySQL
description = models.CharField(max_length=256)

# 36fb332b39a7e05c666d46d7a04d392dcd3a2b880bd564225a4be27dbf092c3e
docker_id = models.CharField(max_length=64)
# jimmy-app
docker_name = models.CharField(max_length=64)
# docker.io/jimmy/jimmy-app
docker_url = models.CharField(max_length=256)
	\end{minted}
	\caption{Alternative model for Container}
	\label{fig:alt-model}
\end{figure}

WebSockets were first explored in this prototype as an option for providing a continuous stream of the temporary data to
the frontend. Consumers for streaming log data and status information were created in the form of classes
inheriting from Django Channels's provided AsyncWebsocketConsumer class. These consumers were able to implement a form
of efficient, async-capable long polling that works for the project spec.

The primary design flaw of this prototype was a lack of clean templates. No React components were incorporated, and therefore
the frontend code to handle WebSockets is bundled with standard Django templates in a vanilla JS script.

From this prototype and its results, the team established goals to find libraries to make frontend use of WebSockets easier
and more convenient, enforce a sensible separation between DRF-provided viewsets and standard Django function-based views,
and document and test the written API.

This prototype also revealed issues of container identity management, Compose interoperability, and the inclusion of source code
for target vulnerable webapps. These design issues were clarified in a meeting with our sponsor, further refining the MVP and appropriately
modifying its scope.

\end{document}
