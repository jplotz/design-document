\documentclass[12pt]{article}

\usepackage{minted}

% for clickable ToC
\usepackage[hidelinks]{hyperref}

\usepackage{float}
\usepackage{graphicx}
\graphicspath{{graphics/}}

\usepackage[margin=1in]{geometry}
\usepackage{setspace}
\onehalfspacing

% Include a list of logos of some of the project's tech stack,
% all on one line. Each logo is limited to a maximum size of 1"x1"
% per the assignment instructions. It isn't mentioned explicitly
% but I would assume numbered captions are not required for simple logos.
\newcommand{\onelinelogos}{
\begin{figure}[H]
	\centering
	$\vcenter{\hbox{\includegraphics[keepaspectratio,width=1in,height=1in]{django-logo-negative}}}$
	\hspace{0.1in}
	$\vcenter{\hbox{\includegraphics[keepaspectratio,width=1in,height=1in]{python-logo}}}$
	\hspace{0.1in}
	$\vcenter{\hbox{\includegraphics[keepaspectratio,width=1in,height=1in]{javascript-logo}}}$
	\hspace{0.1in}
	$\vcenter{\hbox{\includegraphics[keepaspectratio,width=1in,height=1in]{docker-logo-blue}}}$
	\hspace{0.1in}
	$\vcenter{\hbox{\includegraphics[keepaspectratio,width=1in,height=1in]{aws-logo}}}$
\end{figure}
}

% For simple quarter-page graphics.
% Parameters: filename, caption, label
\newcommand{\simplegraphic}[3] {
\begin{figure}[H]
	\centering
	\includegraphics[keepaspectratio,height=0.25\textheight,width=\textwidth]{#1}
	\caption{#2}
	\label{#3}
\end{figure}
}

% Half-page graphic ("very complex figures or screenshots with a lot of information").
% Parameters: filename, caption, label
\newcommand{\complexgraphic}[3] {
\begin{figure}[H]
	\centering
	\includegraphics[keepaspectratio,height=0.5\textheight,width=\textwidth]{#1}
	\caption{#2}
	\label{#3}
\end{figure}
}

\usepackage{subfiles}


\title{Preliminary Design Document}
\author{
	Dustin Allen
	\and
	Daniel Armas
	\and
	Rithik Dhakshnamoorthy
	\and
	Jacob Plotz
	\and
	Luke Samuel Sandoval
	\and
	Jereme Saunders
}
\date{October 2025}

\begin{document}

\maketitle

% Should not be more than two pages in the final PDF
\tableofcontents

\section{Executive Summary}
Imagine you have an epiphany: I need to practice SQL injection. Suppose this is an immediate need. What is your next step?

If you're anything like the typical student, you will turn to a search engine and find small, toy examples which have little relation to real-world examples, or labs hiding behind paywalls. You might opt for a self-hosted solution, but in that case, be prepared to take an hour or more setting up your target application.

Enter the Web App Deployment Tooling (WADT) project. WADT provides an easy-to-use GUI that hides the details of setup and installation so that students can practice as soon as they sit down, no tedium required. A number of preconfigured target applications are available for use, all using a robust open-source tech stack.

\section{Project Description}

\subsection {Overview}
The Web App Deployment Tooling (WADT) project allows students and instructors to browse a catalog of ready-to-deploy vulnerable webapps and manage them through a graphical interface. WADT is the first step in the learning pipeline that ensures students and instructors are on the same page in minimal time. Their efforts can shift to investigating the app itself, while the container-based architecture of WADT ensures they have reproducible sandboxed builds available at the click of a button.

\subsection{The Setup Timesink Problem}
Cybersecurity students want to practice exploiting and patching vulnerable webapps. When they sit down to practice, their time is eaten up by installation and setup before they can start hacking.

Cybersecurity instructors want to provide labs for their students. These labs require research, setup, installation, and testing. The instructor must take the time to guide each student through the same prerequisite steps before the real learning can begin.

Both parties are capable of following a list of instructions to set up a target webapp. These skills are not the desired target of practice. However, requiring setup work on a per-lab basis means wasting learning time.

\subsection{Project Goals and Objectives}
WADT aims to eliminate redundant setup work by providing a standardized environment where vulnerable web apps can be deployed instantly in isolated containers. This ensures reproducibility, simplifies lab setup, and allows both instructors and students to focus on the learning objectives.

\section{Minimum Viable Product}

\subsection{Scope and Limitations}
WADT is intended to be used in an instructional setting as part of a lab. While all code developed for the project is free and open-source, the site and the AWS instance it runs on are not accessible to the general public. The team members and sponsor are the only individuals expected to access the site and instance while it is in early development.

Later in development, our users will access both the WADT site and the instance through their instructor similar to how we have accessed these two resources. We expect that users (assisted by instructors) are capable of reproducing our instructions for accessing the instance and authenticating to access the site when we provide these documents.

The current scope of WADT does not provision for multiple concurrent users at a time with containers managed on a per-identity basis. Each container may be associated with one and the same identity, under the assumption that students will actively collaborate and share management of the containers.

\subsection{Hosting and Security Considerations}
Hosting vulnerable applications on a public, internet-facing server is considered a bad practice. Special precautions must be taken to ensure that malicious actors cannot compromise the instance through a vulnerable container, and that the containers themselves are not compromised and used for criminal purposes.

A viable solution may be to avoid hosting the site at all. It is technically possible for the site to be kept local-only and require each student to download and run the project from their own machine. However, this would largely defeat the purpose of the project as it would require its own setup and installation steps.

Another option may be to install and configure the project local-only on the AWS instance but avoid exposing the instance to the public internet. Each student would be required to connect to the instance through a VPN. The preceding two solutions are dead simple to the point of being below the level of sophistication expected of a 9-month project.

A more feasible solution would be to host the site and add an extremely restrictive security configuration. The instance could be configured to only accept incoming traffic from and send outgoing traffic to a small number of IPs or an IP range explicitly listed in a whitelist. This solution is ideal if the machines used in the lab have IP addresses that fall within a specific range or are unlikely to change over a semester-long course. Under this scheme, the target webapp containers would be blocked from making requests to third parties. Discretion would be left up entirely to the students (a rogue student would have the ability to change the whitelist).

\subsection{Vulnerable App Selection and Containerization}
In order to give our users a variety of options to choose from, we want to select a diverse set of vulnerable web applications. There is an existing registry of vulnerable web applications known as the OWASP Vulnerable Web Applications Directory (VWAD). This registry contains a variety of web applications that are intentionally designed to be vulnerable for educational purposes. We will select at least 7 web applications from this registry that cover a range of vulnerabilities and technologies.

The web applications listed in this registry record the technologies used as well as the specific vulnerabilities they contain. This information will help us ensure that we are providing a comprehensive and varied set of applications for our users to work with.

Creating a quality docker image for each web application is a non-trivial task. We will need to ensure that each image is reliable (it always deploys when required) and reproducible (the application source code and initial state are immutable and consistent). This may involve creating custom Dockerfiles, configuring the applications correctly, and testing the images thoroughly.

\subsection{Technical Debt and Maintainability}
While we may assume one identity controls all containers, it may still be smarter in the long run to design for the possibility of multiple concurrent users, even if this isn't made possible by our hosting configuration.

Since "make it support multiple users" is an excellent goal if this project returns to Senior Design, we will design for the possibility of this extension by programmatically tracking container IDs and associating them with the user's identity and actions. This design decision also makes it easier for us to manage state and tell the user "You cannot stop a container you haven't deployed!" even in the single-user version of WADT.

As a stretch goal, future teams that work on this project would be able to extend our API instead of rewriting it.

\subsection{"Do One Thing Well"}
WADT is a stage in a learning pipeline. Pipelines are made possible by small, focused applications that do one thing well and rely on standard interfaces. WADT is an abstraction for managing containers. It is not an abstraction over the process of finding API endpoints, making requests, patching, and testing. Therefore, WADT should use conventional input and output formats and get out of the way of the user's preferred tools.

If all the user needs is a URL, provide the URL in an easy-to-copy format. Nothing else.

\subsection{Definition of Done}
\begin{itemize}
	\item At least 7 target vulnerable webapps are listed on the site with icons, names, and descriptions. An image for each webapp has been created and tested for reliability (always deploys when required) and reproducibility (application source code and initial state are immutable and consistent). Each target app passes automated tests ensuring that the desired vulnerable endpoints are confirmed reachable.
	\item Container limits. Each container is allotted a specific amount of compute resources and network bandwidth. Each container is only kept running for a maximum of 24 hours from the last user interaction, at which point it will be automatically downed.
	\item Status indicator. Each webapp indicates its state. State indication matches actual container behavior (does not indicate stop when container with specified ID is still running, etc.).
	\item Deploy feature. Users can deploy any of the target webapps. Deploy is accompanied by connection information, assisting users in making requests to the vulnerable application.
	\item Stop feature. Users can stop any webapp. Stop only functions for containers which are currently running.
	\item Restart feature. Users can restart each webapp. "Restart" in this context means stop the webapp the student has been working on patching and start it again.
	\item Reset feature. "Reset" means to stop the version of the app the student has been working on, and deploy the original image before any modifications were made.
	\item Instructor controls. Site admins can view logs with the status of each container. Each deploy, stop, and restart action is logged. Admins have the option of deploy, stop, and restart, and their actions override the wishes of users (while preventing race conditions and state inconsistency). Instructors have the option to "disable" a container, meaning that the container leaves control of the students and only the instructors can manage it. When a container is disabled, students are unable to make any state changes to the container.
	\item Student-facing logging. Student-facing logs must provide a window into the container's behavior, without burdening the student with unnecessary Docker-specific details. For students, no single action in the UI should require scrolling the view of the logs (everything resulting from one action should fit on one view). All major interactions through the UI should be logged with timestamps. The logger must preserve history from the moment the container is started to the moment it is manually downed or auto-downed after 24 hours. In the event of an error resulting from a failed attempt to patch a vulnerability, the student must receive the full error message.
	\item Instructor-facing logging. Must show timestamped logs of all actions taken through the UI by students. Must show container status changes. Uptime for each container must be available to instructors.
\end{itemize}

\subsection{Stretch Goals}
\begin{itemize}
	\item Instructor-facing controls to add new containers. The admin interface provides a method to upload a custom Dockerfile and add that image to the catalog. Instructors will be able to add container metadata (name, description, tags, category, etc.). This new container will function identically to the containers built-in to the site.
	\item Automatic patch checking. User communicates which API endpoints they wish to patch, and the site automatically checks periodically if that endpoint is still vulnerable. Status reports are generated showing which of a set of endpoints are still reachable at the time the report is generated.
	\item UI allows editing of network settings per-container. Users can customize port number on a per-container basis through the UI.
	\item System resource usage display. Admin UI displays, in addition to container uptime, CPU, memory, and network usage for each container.
	\item Custom colorschemes.
	      Make site compatible with widely used color scheme file formats (minimum: .Xresources, .itermcolors, Windows settings.json, and .yml used for GNOME terminal and xfce4 terminal). Students will be able to use the same colors for WADT and for their terminal.
	\item Custom interactions window. Users can issue (arbitrary) commands to the container through the site. Users may edit files with a text editor through the site. This stretch goal is extremely ambitious. The security vulnerabilities potentially resulting from exposing a shell to a container are numerous and severe. Additionally, embedding a full terminal emulator inside of a webapp is a difficult task.
\end{itemize}

\subsection{Tech Stack}
\onelinelogos

% Describe technologies used to make MVP possible
\section{Research}

\subsection{Hosting Provider}
\subsubsection{DigitalOcean}
DigitalOcean droplets are small-sized virtual machines that are billed on a monthly basis.
The team has previous experience using DigitalOcean droplets for hosting, making a Basic droplet a potential choice. However, since WADT is a SaaS application, in DigitalOcean's own terms a Basic droplet may not suffice. Additional tiers of compute and memory would impose an unfair cost on the student group.

\subsubsection{BuyVM}
BuyVM virtual machines are cheaper than a DigitalOcean droplet, but lack the support and convenient admin UI of DigitalOcean or AWS. BuyVM would allow maximum control and potentially a relatively unique hosting stack comprised of a hardened *BSD distribution. However, this route was not chosen for the first iteration of WADT due to the high learning curve.

\subsubsection{AWS}
AWS EC2 was recommended by our sponsor and provided and paid for by our sponsor. This made it an attractive option for the team, even if the pricing model creates risks and additional considerations regarding extensive network traffic. AWS benefits from extensive documentation and high configurability. Ultimately, a single instance was chosen to start with the option of scaling to additional instances as usage of the project grows.

\subsection{Host Operating System}
\subsubsection{OpenBSD}
OpenBSD is a security-focused UNIX system. While using a security-focused system for a cybersecurity-focused project is a good idea, the relative scarcity of documentation meant a steep learning curve for the team.

Considering a *BSD distribution was quickly invalidated as the team determined that Docker is a Linux-specific application. Docker relies on Linux kernel namespaces as part of its core design, meaning that to use a *BSD distribution would require dramatic changes in other parts of the project, effectively invalidating WADT's original purpose. A BSD-based project would make use of Jails instead of Docker. Since users expect to manipulate Docker containers with WADT, changing to BSD would require a change in our MVP, making it more than a mere technical decision.

\subsubsection{CentOS}
CentOS is a Linux distribution which is used internally for the labs run by our sponsor. For the purposes of our users, the main functional difference they will experience between CentOS and other choices of distribution is the package manager. Key project pieces (Docker, NGINX, etc.) are available for every Linux distribution the team considered, the only difference between them being familiarity.

It was decided to optimize for our developer team's productivity in the beginning, and since no member had previous experience with CentOS, it was decided to postpone its adoption. WADT can be migrated to CentOS for lab instructors and students once its core features are developed.

\subsubsection{Amazon Linux}
Amazon Linux is a distribution provided by Amazon specifically for EC2 instances. Its primary advantage for the team would be easy integration with IaC tools like Terraform and CloudFormation.

Amazon Linux is not ideal for either developers or users in terms of previous experience and familiarity. It is not used internally within labs and was not used for testing and early development.

\subsubsection{Ubuntu}
Ubuntu was chosen to promote a fast ramp-up and make it easy for every member of the team to contribute. Ubuntu is an ideal choice, since it supports all elements of the project tech stack and is widely-used.

Specifically, Ubuntu by default enforces an externally-managed Python environment which effectively necessitates using virtual environments to manage project dependencies. This ensures no developers have conflicts between project-specific packages and system-wide packages and reduces dependency conflicts.

PostgreSQL is also available in Ubuntu's default repositories, simplifying project setup when compared to CentOS or Amazon Linux.

\subsection{General Security Concerns}
Security was one of the biggest concerns as hosting intentionally vulnerable applications inherently has many risks that need to be narrowed down and handled before pushed to a live server. Docker has some very strong security primitives that will be utilized to help the application be as secure as possible. Linux namespaces will be used to help ensure that each container has its own isolated process tree, filesystem, and network stack, ensuring that the containers are self-contained and unaware of the host system. A dedicated, isolated Docker bridge network will be used for each student's session. Containers will not be attached to the default bridge or the host network. Using this will aid in preventing these containers from scanning or attacking other services on the host machine/other containers. This essentially enforces a "deny by default" policy for communication within the containers and system itself.

One of the other main concerns was the containers not shutting down on time or a student potentially forgetting to shut down the container itself. Not only would this potentially lead to high overhead costs, it would also potentially leave an opening for a security breach to happen. Due to this, a life time limit will be implemented on the containers to automatically run a stop command to ensure that the containers do not run for extended periods of time. This will help us cleanup our resources along with limiting the potentials for misuse.

\subsection{Incoming Requests}
Arbitrary command execution vulnerabilities are present for a number of selected target vulnerable webapps.

Suppose for a case example, the Damn Vulnerable Web Application (DVWA) selected by the team. DVWA includes a PHP remote code execution lab. Since arbitrary command execution is built-in to the target webapp, the slightest misconfiguration of the underlying Docker container will compromise the server.

Example exploitation steps:
\begin{enumerate}
	\item Misconfigure Docker containers. In this example, a user uses a DVWA compose file with \texttt{privileged: true} and \texttt{pid: "host"} configured for each container
	\item User starts DVWA with \texttt{docker compose up} with root privileges
	\item User configures DVWA built-in security level to low using environment variables, config file, or webpage
	\item User accesses command injection vulnerability in browser at /vulnerabilities/exec
	\item User enters \texttt{localhost; ls /dev} to verify injection vulnerability. Devices on the host are listed. In this instance, the shell runs as user www-data, meaning that exploitation possibilities are roughly the same as a non-root user on the host. In the event of a privilege escalation vulnerability, the user may gain root access
	\item For this demonstration, the user runs a fork bomb
		\simplegraphic{fork-bomb}{Command injection - fork bomb setup}{fig:forkbomb}
	\item A significant slowdown occurs on the host system. In principle, a user could perform this attack on the WADT site to take it offline
		\simplegraphic{cannot-fork}{Command injection - fork bomb execution}{fig:forkbomb-exec}
\end{enumerate}

\subsection{Outgoing Requests}
In addition to concerns that users could compromise the WADT site through any one of its containers, there is the additional concern that the containers could be manipulated to perform malicious outgoing requests. Containers, if compromised, could participate in DDoS, botnets, or be used to distribute illegal content, to name a few examples.

This problem is especially difficult to solve since blocking all outgoing requests will break any dependencies that target vulnerable webapps have on external services.

%TODO provide example

\subsection{XSS}
%TODO explain how users mess with other users through XSS

\subsection{2-Factor Authentication}
In addition to previous security methods, it is desirable to add 2-factor authentication upon login. There are multiple approaches which solve the problem.

\subsubsection{pyotp + pass + pass-otp}
This solution implements TOTP (Time-based One Time Password) authentication, a form of 2-factor authentication, that relies on SSH access to the AWS instance which runs the site. This restriction ensures that the only users who can manipulate containers through the site \textit{already} have full server access as a prerequisite.

The setup steps are as follows:
\begin{enumerate}
	\item Use \texttt{pyotp} to generate a shared secret
	\item Display the shared secret as a URI to the user on the WADT webpage. Other display options include QR code
	\item User logs in to the instance over SSH
	\item User uses \texttt{pass} with the \texttt{pass-otp} extension to store the URI
\end{enumerate}

The usage steps are as follows:
\begin{enumerate}
	\item User logs in to the instance over SSH
	\item User runs \texttt{pass otp [secret-name]} to generate a one-time sign in code
	\item User enters sign in code (or copies it) to the WADT site
	\item User completes signin
\end{enumerate}

While this solution is minimal, it relies on existing libraries and services for the core parts of TOTP, sidestepping documented issues with roll-your-own TOTP like floating point imprecision when calculating the time input.

This solution is also compatible with existing, more standardized authentication providers like Microsoft Authenticator, making it a sensible addition to the project.

All users who access WADT may be required to have SSH access to the underlying server as a prerequisite if it is ensured that only the \texttt{pass} program on the server is configured for MFA.


\subsubsection{Traditional Authentication Providers}
Traditional auth providers are available, most notably Microsoft Authenticator and Google Authenticator, that can provide the same service as \texttt{pass-otp} for users. However, since these traditional providers are not linked to the underlying hosting, they do not provide the same kind of security that the previous solution affords.

Traditional 2FA providers are primarily concerned with verifying the identity of users. Microsoft authenticator in and of itself will verify that the individual attempting a sign-on is the identity they claim to be. However, a solution with \texttt{pass-otp} also incidentally verifies that the individual attempting sign-on has access to the resources the WADT project is looking to protect.
%TODO explain how adding traditional auth provider would work

%TODO add more to security section

\subsection{Containerization Tools}
\subsubsection{OCI Compliance}
The Open Container Initiative (OCI) maintains a group of three specifications which containerization tools are expected to follow to be compliant to the same standards as Docker. Since Docker was taken as a baseline technology for the project, only other OCI-compliant containerization tools were considered.

\subsubsection{Podman}
Podman is a drop-in replacement for Docker which is both daemonless and rootless. It differs in its underlying architecture: Podman is pod-based. A pod is an infra container combined with a number of regular containers.

For comparison, plain Docker functions interacts with plain containers, not pods. Docker Compose can be used to run multiple containers together for a project.

\simplegraphic{podman-pod-architecture}{Pod architecture}{fig:podman}
% TODO source: https://developers.redhat.com/blog/2019/01/15/podman-managing-containers-pods#

Podman's daemonless design means that it does not require a running background process (daemon) to function. Instead, Podman relies on systemd. This is in contrast to Docker, which requires a daemon with root privileges.

Podman is also rootless, meaning that system root privileges are not required by any part of Podman to run containers. This feature is the biggest draw of Podman over Docker for a security-focused project. With Podman, WADT would never require root privileges to run containers or be forced to interact with a privileged daemon process.

Although Podman is intended as a drop-in replacement for Docker, there are minor differences which ultimately led to the team's selection of Docker instead. Docker can perform pulls from DockerHub with short image names, while Podman requires additional configuration to do so. So while \texttt{docker pull postgres} will run successfully, \texttt{podman pull postgres} will throw an error.

These small differences are likely to create cognitive friction for users of WADT.


\subsubsection{Docker}
Docker is a widely-used set of container tools. A number of features made Docker the ideal choice for WADT.
\begin{itemize}
	\item Official, extensive SDK with available low-level API access
	\item Images already available for numerous applications. While any OCI-compliant container engine can run these images, in practice they are built and tested for Docker
	\item DockerHub integration
\end{itemize}

\subsection{Programming Language and Web Framework}

\subsubsection{Python and Flask}
%TODO
Too minimal

\subsubsection{Golang and Gin}
%TODO
Too minimal. Also golang is a new language for i assume most or all of the team

\subsubsection{Python and Django}
Django is a web framework for Python which was chosen for its sensible architecture and useful features. Django's ORM and admin panel made configuring the database a one-day job, while its migrations feature ensures that any changes are tracked along with the project.

Django's MVC architecture and template system enforces clear separation of concerns and makes prototyping fast and easy. Combined with its powerful ORM, simple views can be implemented in a few lines of code.
\begin{figure}[H]
	\centering
	\begin{minted}{python}
	def index(request):
	    container_catalog = Container.objects.order_by("name")
	    context = {"container_catalog": container_catalog}
	    return render(request, "wadtapp/index.html", context)
	\end{minted}
	\caption{Django queries and template system make simple pages simple to write.}
	\label{fig:indexview}
\end{figure}

\subsection{Docker Integration}

\subsubsection{python-on-whales}
%TODO
good, but only for Docker Compose

\subsubsection{go-sdk}
%TODO
not using it because we're not using go

\subsubsection{docker-py}
%TODO
good

\subsection{Asynchronous Support}

\subsubsection{Celery}
%TODO
too complex

\subsubsection{Django Channels}
%TODO
good. prevents the client from repeatedly polling the server

\subsection{Backend Architecture}

\subsubsection{Django MVC}
%TODO
what's meant here is using django's built in stuff for rendering HTML templates with whatever data you want.

\subsubsection{API-only}
%TODO
what's meant here is using Django to create an API that just sends and receives JSON and doesn't take responsibility for rendering pages, which is what we're actually doing.


\subsection{API Testing}
%TODO

\subsubsection{cURL}
%TODO
yay!

\subsubsection{Postman}
%TODO
ew

\subsection{API Documentation}
%TODO

\subsubsection{Hoppscotch}
%TODO
free and open-source

\subsubsection{SwaggerHub}
%TODO
I don't like swaggerhub

\subsection{API Performance Testing}
%TODO

\subsection{Secrets Management}
%TODO
TruffleHog

\subsection{CI/CD Pipeline}
%TODO

\subsection{Chosen API Tools}
For API implementation, some of the biggest considerations are what will potential students need to have access too and what will make this project the easiest to utilize. Along with this we also had to ensure that interfacing with Docker would be seamless to ensure that we could control the container instances while minimizing the potential risks of security issues. Due to this the project was decided to run on Python as Docker SDK for python was the most feature-rich and had the best integration with the Docker engine. With the integration this project will have much easier implementation of the core operations needed to control the containers i.e. start, stop, logs, restart, etc.

For the framework some of the biggest concerns were ensuring that authentication, admin control and security all had proper components available, which is why the final decision was to use Django as our framework for the API. One of the biggest motivators was that Django already has built in authentication features. This allows for users to have secure registration, login, and allows the application to have session management features including user identification without having the need to build up the authorization system from scratch. Django also offers a built-in admin panel along with object relational mapper will help associate users with the containers they are utilizing, and manage user data leading to simpler database operations. REST architecture is also being used as it is the industry standard for web API.

\subsection{API Considerations}
Some other considerations were the usage of web-sockets for our communication protocols as they would provide continuous streaming of live logs or container stats. This was also considered due to the concern of "heisenbugs", race conditions and other overhead related issues such as our client initialization with each user who may be using the application. After research the decision to not utilize web-sockets was that the REST API would be able to handle this much better with less complications of writing and implementing these systems ourselves. The research also provided insight on Docker itself. The realization was that rather than initializing multiple clients when we have multiple users, instead initializing a single shared client would be the best option. This is because Docker already uses different request threads which will help us prevent race conditions or any "heisenbugs" that were anticipated at first. Using this Docker client management we also avoid high overhead costs as the clients are only created once the app boots up, it is inherently designed to be shared across threads while keeping user data separate, and prevents the need for database space being taken.

\subsection{Database}

\subsubsection{MySQL}
%TODO
bruh absolutely not

\subsubsection{MariaDB}
%TODO
better but still MySQL is kinda clunky

\subsubsection{MongoDB}
%TODO
requires a third-party backend to be used with Django

\subsubsection{PostgreSQL}
%TODO
well-supported, easy to install and once you figure out how to set it up, it's not that hard to reproduce those steps.

\subsection{Container Identity Management}
%TODO
the problem of figuring out which container is which. container name and container id are both guaranteed to be unique by docker, but which one we need to use depends on context.

\subsection{Docker Compose}
%TODO
docker compose afaik requires a different python library than just
one-container-at-a-time, which means if any webapps we want on WADT
use compose, we need a way to use a different library to control them.

\subsection{Docker Architecture}
% Docker team content follows


\section{Frontend}

\subsection{CSS Libraries}
When it comes to frontend work, part of the problem is making sure that a website looks appealing enough to attract users, providing a more enjoyable coding experience for the developer and ensure pleasurable user experience. %Maybe rethink this line here

With this in mind, we wanted to choose a professional CSS library that provides the user with good readability and accessibility.
There were a lot of options for CSS libraries, but we narrowed the options down to three: Bootstrap, Tailwind and Chakra UI.

\subsubsection{Bootstrap}
This one was our first consideration, as bootstrap is a very popular CSS library.
Bootstrap and REACT have their own merged CSS library that makes coding the project smoother called 'REACT-Bootstrap'.
REACT-Bootstrap utilizes the bootstrap visuals with REACT type programming to ensure a coherent coding experience.

Bootstrap's reviews are overall positive, with extensive praise on the use of child themes.
Its REACT-Bootstrap also gets pretty high reviews, being praised for it's developer friendly nature.
The only major complaint on Bootstrap is it's lack of flexibility, requiring the developer to edit the CSS code themselves to achieve the desired look.

There are also custom themes for bootstrap to use that can be found online.

One example is 'Bootswatch', which provides free themes for bootstrap that can be easily implemented into the project.
Utilizing these themes can help us achieve a more unique look for our project, and possibly implement different themes for the user to choose from.

\subsubsection{Tailwind}
Tailwind is another popular CSS library containing many good options for CSS design.
Through research, we found that tailwind operated very differently from bootstrap, as it is a utility-first CSS library.
This means that instead of having pre-designed components like bootstrap, tailwind gives a lot of freedom to the developer to design their own components using CSS.

Tailwind reviews are good, with 63\% of the reviews on their website being 5 star.
A complaint that we have noticed when it came to tailwind is that while it is versatile and useful, there is a learning curve.
It suggested that those who don't have extensive knowledge on CSS will struggle a little to utilize tailwind's components.

Unlike Bootstrap which has it's own REACT library, tailwind does not have one.
Instead, tailwind has it's own third party library called Tailwind UI that integrates tailwind with REACT.
However, this third party library is locked behind a paywall, requiring the developer to pay to use it.
Our research concludes that tailwind is extremely versatile for CSS design, however requires a learning curve.

\subsubsection{Chakra UI}
Chakra UI also came across our radar as a popular CSS library.
On Chakra's website, there was a page that showcased the professional websites made using Chakra UI.
This was a nice way to look at what a fully developed website using Chakra UI can do.

Chakra UI's reviews are mostly positive, with emphasis on good developer experience.
A downside to Chakra UI is a lack of certain components (one example is the search bar component), as well
as good ways to change the themes of the components.

% Chakra UI + Figma Kit?
Chakra UI is also developer friendly with Figma with their Chakra UI + Figma Kit.
We found it interesting that there was a Figma page that showed us exactly what to use for certain components.
This was a nice touch that made us consider Chakra UI more seriously since we used Figma for our design mockups.

\subsubsection{What we chose}
After weighing all considerations, our team selected \textbf{REACT-Bootstrap} as our primary CSS framework.
It offers a familiar structure, excellent documentation, and seamless integration with React,
enabling us to focus on functionality without getting bogged down in complex setup processes.

Additionally, having a developer with prior Bootstrap experience allowed us to accelerate onboarding
and maintain consistency across our components.
While Tailwind and Chakra UI both provide unique advantages — creative freedom and modern theming,
respectively — React-Bootstrap strikes the most effective balance between stability, usability, and developer productivity.

\subsection{Wireframing}
Wireframing is an essential component of front-end development; it serves as the blueprint from which all design and implementation decisions follow.  Like all blueprints, its primary goal is to serve as a medium of communication. Communication is the foundation of any collaborative effort, and wireframing provides the first stage of communication for the front-end team. It is important that the frontend team uses a tool that will allow us to work together on designs to ensure we are on the same page before implementation. It is much easier to tackle a large problem with a clear objective in mind prior to implementation. This will improve efficiency and lead to a better overall result. It is also important that we have the flexibility to make changes and add to designs as we progress further into the project and gain a better understanding of our end goals.

While we are the first group to work on this project, it is entirely possible that future Senior Design teams will continue our work. Therefore, documenting and wireframing all of our designs serves as an important organizational tool, not only for our current team but also for any future teams to draw inspiration from or build upon our designs.

\subsubsection{Decision Criteria}
There are many wireframing tools available, so it was important to establish clear decision criteria to guide our final decision. Since this project focuses on building an educational web application, practicality and clarity were our main priorities rather than highly complex or flashy design features. The major factors we considered included:
\begin{itemize}
	\item Ease of Use. In order to begin implementation as soon as possible, we prioritized researching tools that are intuitive, beginner-friendly and have a well-established resource for working with the tool.
	\item Collaboration Features. The ability to work together both in real time and asynchronously through sharing feedback easily was essential. Effective collaboration ensures smooth communication across the team and aligns with the overall goal of efficient group work.
	\item Cost. As students, we aimed to minimize additional expenses and preferred tools that offered strong free versions or educational discounts
	\item Flexibility. We wanted tools that could support our needs without requiring excessive plug-ins or extraneous tools to work sufficiently.
\end{itemize}

\subsubsection{Figma}
Figma was the first technology we considered, as it is one of the most widely used and well-supported wireframing and UI design tools available today. A notable feature of Figma is its emphasis on real-time collaboration. Multiple team members can work on or view the same design simultaneously, which allows for instant feedback and streamlined communication. Figma’s commenting feature also makes it easy to communicate asynchronously, which is very helpful as scheduling meetings at the same time can be difficult throughout the week.

Sharing designs is also extremely easy with Figma, as links can be shared with anyone, including non-front-end team members, for feedback or review of designs. Figma also offers a large collection of community resources, like templates, plug-ins, and tutorials, which help users get acclimated to the software quickly. While Figma is capable of supporting more high-level designs, its basic functionality is straightforward and practical for our project.

Our main concern with Figma was its potential cost. While there is a free version, we were unsure if the free version would be overly limiting. Fortunately, we found that the free plan provided all the core features we needed for the project. The paid version, priced at around 15 dollars per month, could be considered later if premium features became necessary. The month-to-month payments would be manageable if deemed necessary. Figma also works well on all major operating systems, so it would be easily accessible for everyone on the team. Overall, Figma met nearly all our criteria as it is collaborative, user-friendly, and cost-effective given our current scope.

\subsubsection{Canva}
Another tool we considered was Canva. Although Canva is not a traditional UI/UX design platform, it can be used effectively for wireframing, especially for projects with simpler design requirements, such as this. Canva's biggest strength is its ease of use. It has an easy-to-use drag-and-drop interface. It also has a large variety of templates, icons, and pre-made design elements, making it extremely approachable for beginners. This allows team members to quickly create clear layouts without needing extensive design experience with the tool.

Canva also supports collaborative editing, where multiple users can work on a design at the same time and leave comments similar to Figma. Files are stored in the cloud, making them easily accessible and shareable across different devices, giving it a great amount of flexibility. Canva works on all major operating systems through most web browsers, and it also offers desktop and mobile apps for added flexibility.

In terms of cost, Canva offers a free version that includes most core features, while the premium version costs 13 dollars per month, making it the cheapest of the options considered, if premium features were deemed necessary. Canva also provides educational access for free to students, which could make it even more accessible for our team.

However, Canva does have a major limitation in terms of flexibility. Its heavy use of pre-made templates, while convenient, can be restrictive when trying to create or experiment with more complex designs. This could become a drawback if future teams wish to implement more advanced UI layouts in the future. Despite this, Canva’s simplicity and focus on clarity make it a strong option for an educational web application like ours, where functional, easy-to-understand designs are the top priority.

\subsubsection{What we chose}
After evaluating the most practical tools for our needs, our team ultimately selected Figma as our primary technology for design prototyping. It offered the most balanced combination of collaboration features, accessibility, and functionality. Allowing our front-end team to efficiently plan, iterate, and communicate interface designs.

Figma’s collaboration tools, and ease of sharing designs and information made it especially effective for the needs of this project. Its easy-to-use interface lowered the learning curve for members who were new to working with the tool. Additionally, its extensive library of community resources and templates enabled us to quickly build and refine wireframes that align with our project’s goals and communicate the front-end vision with the rest of the team.
\section{System Architecture}


\section{Timeline and Milestones}

\end{document}
